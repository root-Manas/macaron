#!/usr/bin/env python3
"""
MACARON v2.0 - Massive Automated Comprehensive Asset Reconnaissance & Offensive Nexus
A beautiful, optimized security reconnaissance CLI with modern UI
"""
import argparse
import sys
import json
import os
import shutil
import subprocess
import tempfile
import signal
import re
import time
import threading
from pathlib import Path
from datetime import datetime
from typing import List, Dict, Any, Optional, Set, Tuple
from dataclasses import dataclass, field
from enum import Enum
from concurrent.futures import ThreadPoolExecutor, as_completed
import logging

# Rich for beautiful CLI UI
try:
    from rich.console import Console
    from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn, TaskProgressColumn, TimeElapsedColumn, TimeRemainingColumn
    from rich.panel import Panel
    from rich.table import Table
    from rich.live import Live
    from rich.layout import Layout
    from rich.text import Text
    from rich.style import Style
    from rich import box
    from rich.tree import Tree
    from rich.syntax import Syntax
    RICH_AVAILABLE = True
except ImportError:
    RICH_AVAILABLE = False
    print("[!] Rich library not found. Install with: pip install rich")
    print("[!] Falling back to basic output...")

# ============== CONSTANTS ==============

VERSION = "2.0.0"
BANNER = """
[bold cyan]â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—[/]
[bold cyan]â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘[/]
[bold blue]â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘[/]
[bold blue]â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘[/]
[bold magenta]â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘[/]
[bold magenta]â•šâ•â•     â•šâ•â•â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•â•[/]
[dim]                    v{version} - Security Recon Platform[/]
"""

# Directories
HOME_DIR = Path.home() / ".macaron"
DATA_DIR = HOME_DIR / "data"
CONFIG_DIR = HOME_DIR / "config"
STATE_DIR = HOME_DIR / "state"
LOGS_DIR = HOME_DIR / "logs"
WORDLISTS_DIR = HOME_DIR / "wordlists"

# Console for Rich output
console = Console() if RICH_AVAILABLE else None

# ============== ENUMS ==============

class Mode(Enum):
    WIDE = "wide"
    NARROW = "narrow"
    FAST = "fast"  # New: Quick scan with minimal tools

class Status(Enum):
    PENDING = "pending"
    RUNNING = "running"
    DONE = "done"
    FAILED = "failed"
    SKIPPED = "skipped"

# ============== THEME / COLORS ==============

class Theme:
    """Color theme for the UI"""
    PRIMARY = "cyan"
    SECONDARY = "blue"
    SUCCESS = "green"
    WARNING = "yellow"
    ERROR = "red"
    INFO = "white"
    DIM = "dim"
    HIGHLIGHT = "bold magenta"
    
    # Stage colors
    STAGE_SUBDOMAIN = "bold cyan"
    STAGE_DNS = "bold blue"
    STAGE_PORT = "bold yellow"
    STAGE_HTTP = "bold green"
    STAGE_URL = "bold magenta"
    STAGE_JS = "bold cyan"
    STAGE_SCREEN = "bold blue"
    STAGE_VULN = "bold red"

# ============== UTILITIES ==============

def ensure_dir(path: Path) -> Path:
    path.mkdir(parents=True, exist_ok=True)
    return path

def is_installed(tool: str) -> bool:
    return shutil.which(tool) is not None

def run_cmd(cmd: List[str], timeout: int = 300, use_proxy: bool = False, stdin_input: str = None) -> Tuple[int, str, str]:
    """Run command with optional proxychains"""
    if use_proxy and is_installed("proxychains4"):
        cmd = ["proxychains4", "-q"] + cmd
    try:
        result = subprocess.run(cmd, timeout=timeout, capture_output=True, text=True, input=stdin_input)
        return result.returncode, result.stdout, result.stderr
    except subprocess.TimeoutExpired:
        return -1, "", "Timeout"
    except Exception as e:
        return -1, "", str(e)

def sanitize(target: str) -> str:
    return re.sub(r'[^\w\-.]', '_', target.replace("https://", "").replace("http://", "").split("/")[0])

def strip_protocol(url: str) -> str:
    return url.replace("https://", "").replace("http://", "").split("/")[0].split(":")[0]

def save_list(filepath: Path, items):
    with open(filepath, 'w') as f:
        for item in sorted(set(items)):
            f.write(f"{item}\n")

def load_list(filepath: Path) -> List[str]:
    if filepath.exists():
        with open(filepath) as f:
            return [l.strip() for l in f if l.strip()]
    return []

def load_config() -> Dict:
    config_file = CONFIG_DIR / "config.json"
    default = {
        "discord": {"enabled": False, "webhook_url": "", "notify_on": ["scan_start", "scan_complete", "vulnerability"]},
        "proxy": {"enabled": True},
        "rate_limits": {"requests_per_second": 50, "threads": 25}
    }
    if config_file.exists():
        with open(config_file) as f:
            return {**default, **json.load(f)}
    return default

def save_config(config: Dict):
    ensure_dir(CONFIG_DIR)
    with open(CONFIG_DIR / "config.json", 'w') as f:
        json.dump(config, f, indent=2)

def get_timestamp() -> str:
    return datetime.utcnow().isoformat() + "Z"

# ============== SCAN CONTEXT ==============

@dataclass
class ScanContext:
    """Holds all scan data and state"""
    target: str
    mode: Mode
    output_dir: Path
    use_proxy: bool = True
    
    # Discovered assets
    subdomains: Set[str] = field(default_factory=set)
    resolved: Dict[str, List[str]] = field(default_factory=dict)
    live_hosts: Set[str] = field(default_factory=set)
    ports: Dict[str, List[int]] = field(default_factory=dict)
    urls: Set[str] = field(default_factory=set)
    js_files: Set[str] = field(default_factory=set)
    endpoints: Set[str] = field(default_factory=set)
    technologies: Dict[str, List[str]] = field(default_factory=dict)
    vulnerabilities: List[Dict] = field(default_factory=list)
    
    # Stats
    errors: List[str] = field(default_factory=list)
    start_time: datetime = field(default_factory=datetime.now)

# ============== TOOL RUNNER ==============

class ToolRunner:
    """Manages running individual recon tools with progress tracking"""
    
    def __init__(self, use_proxy: bool = True, rate_limit: int = 100, threads: int = 25):
        self.use_proxy = use_proxy and is_installed("proxychains4")
        self.rate_limit = rate_limit
        self.threads = threads
    
    def run(self, cmd: List[str], timeout: int = 300, stdin_input: str = None) -> Tuple[int, str, str]:
        """Execute a tool command"""
        return run_cmd(cmd, timeout, self.use_proxy, stdin_input)
    
    # ==================== SUBDOMAIN TOOLS ====================
    
    def subfinder(self, target: str) -> Set[str]:
        """Fast passive subdomain enumeration"""
        cmd = ["subfinder", "-d", target, "-silent", "-all", "-t", str(self.threads)]
        code, out, _ = self.run(cmd, 600)
        return set(l.strip() for l in out.split('\n') if l.strip()) if code == 0 else set()
    
    def amass_passive(self, target: str) -> Set[str]:
        """Amass passive mode with rate limiting"""
        cmd = ["amass", "enum", "-passive", "-d", target, "-dns-qps", "50", "-timeout", "10"]
        code, out, _ = self.run(cmd, 600)
        return set(l.strip() for l in out.split('\n') if l.strip()) if code == 0 else set()
    
    def assetfinder(self, target: str) -> Set[str]:
        """Quick asset finder"""
        cmd = ["assetfinder", "--subs-only", target]
        code, out, _ = self.run(cmd, 300)
        return set(l.strip() for l in out.split('\n') if l.strip() and target in l) if code == 0 else set()
    
    def findomain(self, target: str) -> Set[str]:
        """Fast cross-platform subdomain finder"""
        cmd = ["findomain", "-t", target, "-q"]
        code, out, _ = self.run(cmd, 300)
        return set(l.strip() for l in out.split('\n') if l.strip()) if code == 0 else set()
    
    def crtsh(self, target: str) -> Set[str]:
        """Certificate transparency logs"""
        import urllib.request
        try:
            url = f"https://crt.sh/?q=%25.{target}&output=json"
            with urllib.request.urlopen(url, timeout=30) as resp:
                data = json.loads(resp.read().decode())
                subs = set()
                for entry in data:
                    for name in entry.get("name_value", "").split('\n'):
                        name = name.strip().lower()
                        if name and '*' not in name:
                            subs.add(name)
                return subs
        except:
            return set()
    
    # ==================== DNS TOOLS ====================
    
    def dnsx(self, hosts: List[str]) -> Dict[str, List[str]]:
        """Fast DNS resolution with all records"""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
            f.write('\n'.join(hosts))
            temp = f.name
        try:
            cmd = ["dnsx", "-l", temp, "-a", "-resp", "-json", "-silent", "-t", str(min(self.threads, 100))]
            code, out, _ = self.run(cmd, 600)
            resolved = {}
            if code == 0:
                for line in out.split('\n'):
                    if line.strip():
                        try:
                            data = json.loads(line)
                            host, ips = data.get("host", ""), data.get("a", [])
                            if host and ips:
                                resolved[host] = ips
                        except:
                            pass
            return resolved
        finally:
            Path(temp).unlink(missing_ok=True)
    
    # ==================== PORT TOOLS ====================
    
    def naabu(self, hosts: List[str], top_ports: str = "1000") -> Dict[str, List[int]]:
        """Fast port scanning with service detection"""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
            f.write('\n'.join(hosts))
            temp = f.name
        try:
            cmd = [
                "naabu", "-l", temp, "-json", "-silent",
                "-top-ports", top_ports,
                "-rate", str(self.rate_limit),
                "-c", str(min(self.threads, 25)),
                "-retries", "2"
            ]
            code, out, _ = self.run(cmd, 1800)
            ports = {}
            if code == 0:
                for line in out.split('\n'):
                    if line.strip():
                        try:
                            data = json.loads(line)
                            host, port = data.get("host", ""), data.get("port", 0)
                            if host and port:
                                ports.setdefault(host, []).append(port)
                        except:
                            pass
            return ports
        finally:
            Path(temp).unlink(missing_ok=True)
    
    # ==================== HTTP TOOLS ====================
    
    def httpx(self, targets: List[str]) -> Tuple[Set[str], Dict[str, List[str]]]:
        """HTTP probing with tech detection, CDN detection, and screenshots"""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
            f.write('\n'.join(targets))
            temp = f.name
        try:
            cmd = [
                "httpx", "-l", temp, "-json", "-silent",
                "-sc", "-title", "-td", "-cdn",  # status-code, title, tech-detect, cdn
                "-follow-redirects",
                "-rate-limit", str(self.rate_limit),
                "-threads", str(min(self.threads, 50))
            ]
            code, out, _ = self.run(cmd, 1800)
            live, techs = set(), {}
            if code == 0:
                for line in out.split('\n'):
                    if line.strip():
                        try:
                            data = json.loads(line)
                            url = data.get("url", "")
                            if url:
                                live.add(url)
                                if data.get("tech"):
                                    techs[url] = data["tech"]
                        except:
                            pass
            return live, techs
        finally:
            Path(temp).unlink(missing_ok=True)
    
    # ==================== URL DISCOVERY TOOLS ====================
    
    def gau(self, target: str) -> Set[str]:
        """Get All URLs from archives"""
        cmd = ["gau", "--subs", "--threads", "5", target]
        code, out, _ = self.run(cmd, 300)
        return set(l.strip() for l in out.split('\n') if l.strip()) if code == 0 else set()
    
    def waybackurls(self, target: str) -> Set[str]:
        """Wayback machine URLs"""
        code, out, _ = self.run(["waybackurls"], 300, stdin_input=target)
        return set(l.strip() for l in out.split('\n') if l.strip()) if code == 0 else set()
    
    def katana(self, targets: List[str], depth: int = 3) -> Set[str]:
        """Modern crawler with JS parsing"""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
            f.write('\n'.join(targets))
            temp = f.name
        try:
            cmd = [
                "katana", "-list", temp, "-silent",
                "-d", str(depth),
                "-jc",  # JS crawling
                "-iqp",  # Ignore query params
                "-c", str(min(self.threads, 20)),
                "-rl", str(self.rate_limit)
            ]
            code, out, _ = self.run(cmd, 900)
            return set(l.strip() for l in out.split('\n') if l.strip()) if code == 0 else set()
        finally:
            Path(temp).unlink(missing_ok=True)
    
    def hakrawler(self, targets: List[str]) -> Set[str]:
        """Fast crawling for endpoints"""
        urls = set()
        for target in targets[:5]:
            cmd = ["hakrawler", "-d", "2", "-subs", "-u"]
            code, out, _ = self.run(cmd, 300, stdin_input=target)
            if code == 0:
                urls.update(l.strip() for l in out.split('\n') if l.strip())
        return urls
    
    # ==================== JS ANALYSIS TOOLS ====================
    
    def getjs(self, targets: List[str]) -> Set[str]:
        """Extract JavaScript files"""
        js_files = set()
        for target in targets[:20]:
            cmd = ["getJS", "--url", target, "--complete"]
            code, out, _ = self.run(cmd, 120)
            if code == 0:
                js_files.update(l.strip() for l in out.split('\n') if l.strip() and '.js' in l)
        return js_files
    
    # ==================== SCREENSHOT TOOLS ====================
    
    def gowitness(self, targets: List[str], output_dir: Path):
        """Take screenshots using gowitness v3"""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
            f.write('\n'.join(targets))
            temp = f.name
        try:
            ensure_dir(output_dir)
            cmd = [
                "gowitness", "scan", "file", "-f", temp,
                "--screenshot-path", str(output_dir),
                "--delay", "2",
                "--threads", str(min(self.threads, 8))
            ]
            self.run(cmd, 3600)
        finally:
            Path(temp).unlink(missing_ok=True)
    
    # ==================== VULNERABILITY SCANNING ====================
    
    def nuclei(self, targets: List[str], output_file: Path, severity: str = "critical,high,medium") -> List[Dict]:
        """Template-based vulnerability scanning"""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
            f.write('\n'.join(targets))
            temp = f.name
        try:
            ensure_dir(output_file.parent)
            cmd = [
                "nuclei", "-l", temp,
                "-o", str(output_file), "-jsonl", "-silent",
                "-severity", severity,
                "-rl", str(self.rate_limit),
                "-c", str(min(self.threads, 25)),
                "-nh"  # No update check
            ]
            self.run(cmd, 7200)
            
            vulns = []
            if output_file.exists():
                with open(output_file) as f:
                    for line in f:
                        if line.strip():
                            try:
                                data = json.loads(line)
                                vulns.append({
                                    "host": data.get("host", ""),
                                    "name": data.get("info", {}).get("name", ""),
                                    "severity": data.get("info", {}).get("severity", "info"),
                                    "template": data.get("template-id", ""),
                                })
                            except:
                                pass
            return vulns
        finally:
            Path(temp).unlink(missing_ok=True)
    
    # ==================== CONTENT DISCOVERY ====================
    
    def ffuf(self, target: str, output_dir: Path, wordlist: Path):
        """Fast web fuzzer"""
        if not wordlist.exists():
            return
        output_file = output_dir / f"ffuf_{sanitize(target)}.json"
        cmd = [
            "ffuf", "-u", f"{target}/FUZZ", "-w", str(wordlist),
            "-o", str(output_file), "-of", "json",
            "-mc", "200,201,204,301,302,307,401,403,405",
            "-t", str(min(self.threads, 50)),
            "-rate", str(self.rate_limit),
            "-s"  # Silent
        ]
        self.run(cmd, 600)

# ============== SCAN ENGINE ==============

class MacaronEngine:
    """Main scan orchestrator with beautiful progress UI"""
    
    def __init__(self, use_proxy: bool = True, rate: int = 100, threads: int = 25, quiet: bool = False):
        self.runner = ToolRunner(use_proxy, rate, threads)
        self.quiet = quiet
        self.running = True
        self.notifier = DiscordNotifier()
        
        # Ensure directories
        for d in [DATA_DIR, CONFIG_DIR, STATE_DIR, LOGS_DIR, WORDLISTS_DIR]:
            ensure_dir(d)
        
        signal.signal(signal.SIGINT, self._handle_interrupt)
        signal.signal(signal.SIGTERM, self._handle_interrupt)
    
    def _handle_interrupt(self, signum, frame):
        self.running = False
        if console:
            console.print("\n[yellow]âš  Interrupt received, stopping gracefully...[/]")
    
    def scan(self, targets: List[str], mode: Mode = Mode.WIDE) -> Dict:
        """Execute scan with beautiful progress UI"""
        start = datetime.now()
        self.notifier.scan_start(targets, mode.value)
        
        stats = {
            "mode": mode.value,
            "targets": len(targets),
            "subdomains": 0,
            "live_hosts": 0,
            "ports": 0,
            "urls": 0,
            "vulnerabilities": 0,
            "errors": 0
        }
        
        if console and not self.quiet:
            console.print(Panel(BANNER.format(version=VERSION), border_style="cyan", box=box.DOUBLE))
        
        for i, target in enumerate(targets):
            if not self.running:
                break
            
            ctx = ScanContext(
                target=target,
                mode=mode,
                output_dir=DATA_DIR / sanitize(target),
                use_proxy=self.runner.use_proxy
            )
            ensure_dir(ctx.output_dir)
            
            if console and not self.quiet:
                console.print(f"\n[bold cyan]â”â”â” Target {i+1}/{len(targets)}: {target} â”â”â”[/]\n")
            
            # Run appropriate pipeline
            if mode == Mode.WIDE:
                ctx = self._pipeline_wide(ctx)
            elif mode == Mode.NARROW:
                ctx = self._pipeline_narrow(ctx)
            else:  # FAST
                ctx = self._pipeline_fast(ctx)
            
            # Update stats
            stats["subdomains"] += len(ctx.subdomains)
            stats["live_hosts"] += len(ctx.live_hosts)
            stats["ports"] += sum(len(p) for p in ctx.ports.values())
            stats["urls"] += len(ctx.urls)
            stats["vulnerabilities"] += len(ctx.vulnerabilities)
            stats["errors"] += len(ctx.errors)
            
            self._save_results(ctx)
        
        stats["duration"] = str(datetime.now() - start).split('.')[0]
        stats["status"] = "completed" if self.running else "interrupted"
        
        self.notifier.scan_complete(stats)
        self._print_summary(stats)
        
        return stats
    
    def _run_stage(self, name: str, emoji: str, color: str, tools: List[Tuple[str, callable]], ctx: ScanContext) -> Any:
        """Run a stage with progress tracking"""
        if not self.running:
            return
        
        results = {}
        
        if console and not self.quiet:
            with Progress(
                SpinnerColumn(),
                TextColumn(f"[{color}]{emoji} {name}[/]"),
                BarColumn(bar_width=30),
                TaskProgressColumn(),
                TextColumn("â€¢"),
                TimeElapsedColumn(),
                console=console,
                transient=True
            ) as progress:
                task = progress.add_task("", total=len(tools))
                
                for tool_name, tool_func in tools:
                    if not self.running:
                        break
                    if not is_installed(tool_name.split()[0]):
                        progress.advance(task)
                        continue
                    
                    progress.update(task, description=f"[dim]{tool_name}[/]")
                    try:
                        result = tool_func()
                        results[tool_name] = result
                    except Exception as e:
                        ctx.errors.append(f"{tool_name}: {e}")
                    progress.advance(task)
        else:
            # Quiet mode - no progress bars
            for tool_name, tool_func in tools:
                if not self.running:
                    break
                if not is_installed(tool_name.split()[0]):
                    continue
                try:
                    results[tool_name] = tool_func()
                except Exception as e:
                    ctx.errors.append(f"{tool_name}: {e}")
        
        return results
    
    # ==================== PIPELINES ====================
    
    def _pipeline_wide(self, ctx: ScanContext) -> ScanContext:
        """Full infrastructure recon - optimized pipeline"""
        
        # Stage 1: Subdomain Discovery (parallel passive sources)
        tools = [
            ("subfinder", lambda: self.runner.subfinder(ctx.target)),
            ("assetfinder", lambda: self.runner.assetfinder(ctx.target)),
            ("findomain", lambda: self.runner.findomain(ctx.target)),
            ("crt.sh", lambda: self.runner.crtsh(ctx.target)),
            ("amass", lambda: self.runner.amass_passive(ctx.target)),
        ]
        results = self._run_stage("Subdomain Discovery", "ðŸ”", Theme.STAGE_SUBDOMAIN, tools, ctx)
        for r in results.values():
            if r:
                ctx.subdomains.update(r)
        ctx.subdomains = {s.lower() for s in ctx.subdomains if ctx.target in s.lower()}
        
        if ctx.subdomains:
            save_list(ctx.output_dir / "subdomains.txt", ctx.subdomains)
            self._stage_done("subdomains", len(ctx.subdomains))
        
        if not self.running or not ctx.subdomains:
            return ctx
        
        # Stage 2: DNS Resolution
        tools = [("dnsx", lambda: self.runner.dnsx(list(ctx.subdomains)))]
        results = self._run_stage("DNS Resolution", "ðŸ“¡", Theme.STAGE_DNS, tools, ctx)
        ctx.resolved = results.get("dnsx", {})
        if ctx.resolved:
            save_list(ctx.output_dir / "resolved.txt", [f"{h}: {', '.join(ips)}" for h, ips in ctx.resolved.items()])
            self._stage_done("resolved", len(ctx.resolved))
        
        if not self.running:
            return ctx
        
        # Stage 3: Port Scanning (on resolved hosts)
        hosts = list(ctx.resolved.keys()) if ctx.resolved else list(ctx.subdomains)[:100]
        tools = [("naabu", lambda: self.runner.naabu(hosts, "1000"))]
        results = self._run_stage("Port Scanning", "ðŸ”Œ", Theme.STAGE_PORT, tools, ctx)
        ctx.ports = results.get("naabu", {})
        if ctx.ports:
            save_list(ctx.output_dir / "ports.txt", [f"{h}:{p}" for h, ports in ctx.ports.items() for p in ports])
            self._stage_done("ports", sum(len(p) for p in ctx.ports.values()))
        
        if not self.running:
            return ctx
        
        # Stage 4: HTTP Probing + Tech Detection (include non-standard ports)
        probe_targets = set(ctx.subdomains)
        for host, ports in ctx.ports.items():
            for port in ports:
                if port not in (80, 443):
                    probe_targets.add(f"{host}:{port}")
        
        tools = [("httpx", lambda: self.runner.httpx(list(probe_targets)))]
        results = self._run_stage("HTTP Probing", "ðŸŒ", Theme.STAGE_HTTP, tools, ctx)
        live_result = results.get("httpx", (set(), {}))
        ctx.live_hosts, ctx.technologies = live_result
        if ctx.live_hosts:
            save_list(ctx.output_dir / "live_hosts.txt", ctx.live_hosts)
            save_list(ctx.output_dir / "technologies.txt", [f"{h}: {', '.join(t)}" for h, t in ctx.technologies.items()])
            self._stage_done("live", len(ctx.live_hosts))
        
        if not self.running or not ctx.live_hosts:
            return ctx
        
        # Stage 5: URL Discovery (passive + active)
        clean_domain = strip_protocol(ctx.target)
        tools = [
            ("gau", lambda: self.runner.gau(clean_domain)),
            ("waybackurls", lambda: self.runner.waybackurls(clean_domain)),
            ("katana", lambda: self.runner.katana(list(ctx.live_hosts)[:20], depth=2)),
        ]
        results = self._run_stage("URL Discovery", "ðŸ”—", Theme.STAGE_URL, tools, ctx)
        for r in results.values():
            if r:
                ctx.urls.update(r)
        ctx.js_files = {u for u in ctx.urls if '.js' in u.lower() and not u.endswith('.json')}
        if ctx.urls:
            save_list(ctx.output_dir / "urls.txt", ctx.urls)
            save_list(ctx.output_dir / "js_files.txt", ctx.js_files)
            self._stage_done("urls", len(ctx.urls))
        
        if not self.running:
            return ctx
        
        # Stage 6: JS Analysis
        tools = [("getJS", lambda: self.runner.getjs(list(ctx.live_hosts)[:20]))]
        results = self._run_stage("JS Analysis", "ðŸ“œ", Theme.STAGE_JS, tools, ctx)
        more_js = results.get("getJS", set())
        ctx.js_files.update(more_js)
        if ctx.js_files:
            save_list(ctx.output_dir / "js_files.txt", ctx.js_files)
            self._stage_done("js_files", len(ctx.js_files))
        
        if not self.running:
            return ctx
        
        # Stage 7: Screenshots
        tools = [("gowitness", lambda: self.runner.gowitness(list(ctx.live_hosts)[:50], ctx.output_dir / "screenshots"))]
        self._run_stage("Screenshots", "ðŸ“¸", Theme.STAGE_SCREEN, tools, ctx)
        self._stage_done("screenshots", len(list((ctx.output_dir / "screenshots").glob("*.png"))) if (ctx.output_dir / "screenshots").exists() else 0)
        
        if not self.running:
            return ctx
        
        # Stage 8: Vulnerability Scanning
        tools = [("nuclei", lambda: self.runner.nuclei(list(ctx.live_hosts), ctx.output_dir / "nuclei.json"))]
        results = self._run_stage("Vulnerability Scan", "ðŸŽ¯", Theme.STAGE_VULN, tools, ctx)
        ctx.vulnerabilities = results.get("nuclei", [])
        if ctx.vulnerabilities:
            self._stage_done("vulns", len(ctx.vulnerabilities), is_vuln=True)
            for v in ctx.vulnerabilities:
                if v.get("severity") in ("critical", "high"):
                    self.notifier.vulnerability(v["name"], v["severity"], v["host"])
        
        return ctx
    
    def _pipeline_narrow(self, ctx: ScanContext) -> ScanContext:
        """Application-focused recon"""
        ctx.subdomains.add(ctx.target)
        
        # DNS check
        tools = [("dnsx", lambda: self.runner.dnsx([ctx.target]))]
        results = self._run_stage("DNS Validation", "ðŸ“¡", Theme.STAGE_DNS, tools, ctx)
        ctx.resolved = results.get("dnsx", {})
        
        # Light port scan (web ports only)
        if is_installed("naabu"):
            with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
                f.write(ctx.target)
                temp = f.name
            try:
                cmd = ["naabu", "-l", temp, "-json", "-silent", "-p", "80,443,8080,8443,8000,3000,5000,9000"]
                code, out, _ = run_cmd(cmd, 300, self.runner.use_proxy)
                if code == 0:
                    for line in out.split('\n'):
                        if line.strip():
                            try:
                                data = json.loads(line)
                                h, p = data.get("host", ""), data.get("port", 0)
                                if h and p:
                                    ctx.ports.setdefault(h, []).append(p)
                            except:
                                pass
            finally:
                Path(temp).unlink(missing_ok=True)
        
        # HTTP probe
        tools = [("httpx", lambda: self.runner.httpx([ctx.target]))]
        results = self._run_stage("HTTP Probing", "ðŸŒ", Theme.STAGE_HTTP, tools, ctx)
        live_result = results.get("httpx", (set(), {}))
        ctx.live_hosts, ctx.technologies = live_result
        if ctx.live_hosts:
            save_list(ctx.output_dir / "live_hosts.txt", ctx.live_hosts)
            self._stage_done("live", len(ctx.live_hosts))
        
        if not self.running or not ctx.live_hosts:
            return ctx
        
        # Deep crawling
        tools = [
            ("katana", lambda: self.runner.katana(list(ctx.live_hosts), depth=4)),
            ("hakrawler", lambda: self.runner.hakrawler(list(ctx.live_hosts))),
        ]
        results = self._run_stage("Deep Crawling", "ðŸ•·ï¸", Theme.STAGE_URL, tools, ctx)
        for r in results.values():
            if r:
                ctx.urls.update(r)
        
        # URL discovery
        clean = strip_protocol(ctx.target)
        tools = [
            ("gau", lambda: self.runner.gau(clean)),
            ("waybackurls", lambda: self.runner.waybackurls(clean)),
        ]
        results = self._run_stage("URL Archives", "ðŸ”—", Theme.STAGE_URL, tools, ctx)
        for r in results.values():
            if r:
                ctx.urls.update(r)
        
        ctx.js_files = {u for u in ctx.urls if '.js' in u}
        if ctx.urls:
            save_list(ctx.output_dir / "urls.txt", ctx.urls)
            save_list(ctx.output_dir / "js_files.txt", ctx.js_files)
            self._stage_done("urls", len(ctx.urls))
        
        # JS Analysis
        tools = [("getJS", lambda: self.runner.getjs(list(ctx.live_hosts)))]
        results = self._run_stage("JS Analysis", "ðŸ“œ", Theme.STAGE_JS, tools, ctx)
        more_js = results.get("getJS", set())
        ctx.js_files.update(more_js)
        
        # Content discovery
        wordlist = WORDLISTS_DIR / "common.txt"
        if wordlist.exists() and is_installed("ffuf"):
            ensure_dir(ctx.output_dir / "content")
            for target in list(ctx.live_hosts)[:3]:
                self.runner.ffuf(target, ctx.output_dir / "content", wordlist)
        
        # Screenshots
        tools = [("gowitness", lambda: self.runner.gowitness(list(ctx.live_hosts), ctx.output_dir / "screenshots"))]
        self._run_stage("Screenshots", "ðŸ“¸", Theme.STAGE_SCREEN, tools, ctx)
        
        # Vuln scan (focused)
        tools = [("nuclei", lambda: self.runner.nuclei(list(ctx.live_hosts), ctx.output_dir / "nuclei.json", "critical,high,medium"))]
        results = self._run_stage("Vulnerability Scan", "ðŸŽ¯", Theme.STAGE_VULN, tools, ctx)
        ctx.vulnerabilities = results.get("nuclei", [])
        if ctx.vulnerabilities:
            self._stage_done("vulns", len(ctx.vulnerabilities), is_vuln=True)
        
        return ctx
    
    def _pipeline_fast(self, ctx: ScanContext) -> ScanContext:
        """Quick scan - minimal tools, maximum speed"""
        
        # Fast subdomain enum (only subfinder + crt.sh)
        tools = [
            ("subfinder", lambda: self.runner.subfinder(ctx.target)),
            ("crt.sh", lambda: self.runner.crtsh(ctx.target)),
        ]
        results = self._run_stage("Quick Subdomain Scan", "ðŸ”", Theme.STAGE_SUBDOMAIN, tools, ctx)
        for r in results.values():
            if r:
                ctx.subdomains.update(r)
        ctx.subdomains = {s.lower() for s in ctx.subdomains if ctx.target in s.lower()}
        if ctx.subdomains:
            save_list(ctx.output_dir / "subdomains.txt", ctx.subdomains)
            self._stage_done("subdomains", len(ctx.subdomains))
        
        if not ctx.subdomains:
            return ctx
        
        # HTTP probe only (skip DNS and ports)
        tools = [("httpx", lambda: self.runner.httpx(list(ctx.subdomains)[:100]))]
        results = self._run_stage("HTTP Probing", "ðŸŒ", Theme.STAGE_HTTP, tools, ctx)
        live_result = results.get("httpx", (set(), {}))
        ctx.live_hosts, ctx.technologies = live_result
        if ctx.live_hosts:
            save_list(ctx.output_dir / "live_hosts.txt", ctx.live_hosts)
            self._stage_done("live", len(ctx.live_hosts))
        
        if not ctx.live_hosts:
            return ctx
        
        # Quick vuln scan (critical + high only)
        tools = [("nuclei", lambda: self.runner.nuclei(list(ctx.live_hosts)[:50], ctx.output_dir / "nuclei.json", "critical,high"))]
        results = self._run_stage("Quick Vuln Scan", "ðŸŽ¯", Theme.STAGE_VULN, tools, ctx)
        ctx.vulnerabilities = results.get("nuclei", [])
        if ctx.vulnerabilities:
            self._stage_done("vulns", len(ctx.vulnerabilities), is_vuln=True)
        
        return ctx
    
    def _stage_done(self, name: str, count: int, is_vuln: bool = False):
        """Print stage completion message"""
        if console and not self.quiet:
            color = "red" if is_vuln and count > 0 else "green"
            console.print(f"  [{color}]âœ“[/] {name}: [bold]{count}[/]")
    
    def _save_results(self, ctx: ScanContext):
        """Save scan summary"""
        summary = {
            "target": ctx.target,
            "mode": ctx.mode.value,
            "scanned_at": get_timestamp(),
            "duration": str(datetime.now() - ctx.start_time).split('.')[0],
            "stats": {
                "subdomains": len(ctx.subdomains),
                "resolved": len(ctx.resolved),
                "live_hosts": len(ctx.live_hosts),
                "ports": sum(len(p) for p in ctx.ports.values()),
                "urls": len(ctx.urls),
                "js_files": len(ctx.js_files),
                "vulnerabilities": len(ctx.vulnerabilities)
            },
            "vulnerabilities": ctx.vulnerabilities,
            "errors": ctx.errors
        }
        with open(ctx.output_dir / "summary.json", 'w') as f:
            json.dump(summary, f, indent=2)
    
    def _print_summary(self, stats: Dict):
        """Print beautiful scan summary"""
        if not console or self.quiet:
            return
        
        table = Table(title="Scan Results", box=box.ROUNDED, border_style="cyan")
        table.add_column("Metric", style="cyan")
        table.add_column("Value", style="bold white", justify="right")
        
        table.add_row("Mode", stats["mode"])
        table.add_row("Duration", stats["duration"])
        table.add_row("Subdomains", str(stats["subdomains"]))
        table.add_row("Live Hosts", str(stats["live_hosts"]))
        table.add_row("Open Ports", str(stats["ports"]))
        table.add_row("URLs", str(stats["urls"]))
        
        vuln_style = "bold red" if stats["vulnerabilities"] > 0 else "green"
        table.add_row("Vulnerabilities", f"[{vuln_style}]{stats['vulnerabilities']}[/]")
        
        console.print()
        console.print(table)
        console.print(f"\n[dim]Results saved to: {DATA_DIR}[/]")

# ============== DISCORD NOTIFIER ==============

class DiscordNotifier:
    """Discord webhook notifications"""
    
    def __init__(self):
        config = load_config().get("discord", {})
        self.enabled = config.get("enabled", False)
        self.webhook_url = config.get("webhook_url", "")
    
    def _send(self, title: str, msg: str, color: int = 0x3498db):
        if not self.enabled or not self.webhook_url:
            return
        try:
            import urllib.request
            payload = json.dumps({
                "embeds": [{
                    "title": title,
                    "description": msg[:4000],
                    "color": color,
                    "footer": {"text": "Macaron v2"},
                    "timestamp": get_timestamp()
                }]
            }).encode()
            req = urllib.request.Request(self.webhook_url, data=payload, headers={"Content-Type": "application/json"})
            urllib.request.urlopen(req, timeout=10)
        except:
            pass
    
    def scan_start(self, targets: List[str], mode: str):
        self._send("ðŸš€ Scan Started", f"**Mode:** {mode}\n**Targets:** {', '.join(targets[:5])}", 0x3498db)
    
    def scan_complete(self, stats: Dict):
        self._send("âœ… Scan Complete", f"**Duration:** {stats.get('duration')}\n**Subdomains:** {stats.get('subdomains')}\n**Live:** {stats.get('live_hosts')}\n**Vulns:** {stats.get('vulnerabilities')}", 0x2ecc71)
    
    def vulnerability(self, name: str, severity: str, target: str):
        colors = {"critical": 0xff0000, "high": 0xff6600, "medium": 0xffff00}
        self._send(f"âš ï¸ {severity.upper()}: {name}", f"**Target:** {target}", colors.get(severity.lower(), 0x7289da))

# ============== CLI COMMANDS ==============

def cmd_scan(args):
    """Run a scan"""
    targets = []
    if args.target:
        targets = args.target if isinstance(args.target, list) else [args.target]
    elif args.file:
        targets = load_list(Path(args.file))
    elif args.stdin:
        targets = [l.strip() for l in sys.stdin if l.strip()]
    
    if not targets:
        console.print("[red]âœ— No targets provided[/]") if console else print("No targets")
        return 1
    
    # Mode selection
    if args.fast:
        mode = Mode.FAST
    elif args.narrow:
        mode = Mode.NARROW
    else:
        mode = Mode.WIDE
    
    # Rate limiting
    rate = 10 if args.slow else (args.rate or 100)
    threads = 5 if args.slow else (args.threads or 25)
    
    engine = MacaronEngine(
        use_proxy=not args.no_proxy,
        rate=rate,
        threads=threads,
        quiet=args.quiet
    )
    
    stats = engine.scan(targets, mode=mode)
    return 0 if stats.get("status") == "completed" else 1

def cmd_status(args):
    """Show status"""
    if not console:
        print("Status requires rich library")
        return 1
    
    console.print(Panel(BANNER.format(version=VERSION), border_style="cyan", box=box.DOUBLE))
    
    # Data summary
    if DATA_DIR.exists():
        table = Table(title="Scan Data", box=box.ROUNDED)
        table.add_column("Domain", style="cyan")
        table.add_column("Subdomains", justify="right")
        table.add_column("Live", justify="right")
        table.add_column("Vulns", justify="right", style="red")
        
        for d in sorted(DATA_DIR.iterdir())[:10]:
            if d.is_dir():
                subs = len(load_list(d / "subdomains.txt"))
                live = len(load_list(d / "live_hosts.txt"))
                vulns = 0
                vuln_file = d / "nuclei.json"
                if vuln_file.exists():
                    with open(vuln_file) as f:
                        vulns = len([l for l in f if l.strip()])
                table.add_row(d.name, str(subs), str(live), str(vulns))
        
        console.print(table)
    else:
        console.print("[dim]No scan data yet[/]")
    
    return 0

def cmd_show(args):
    """Show results"""
    if not console:
        return 1
    
    domain = args.domain
    what = args.what or "all"
    limit = args.limit or 50
    
    targets = []
    if DATA_DIR.exists():
        for d in DATA_DIR.iterdir():
            if d.is_dir() and (not domain or domain.lower() in d.name.lower()):
                targets.append(d)
    
    if not targets:
        console.print(f"[yellow]No results found[/]")
        return 1
    
    for target_dir in targets:
        console.print(f"\n[bold cyan]{'â•'*50}[/]")
        console.print(f"[bold cyan] {target_dir.name}[/]")
        console.print(f"[bold cyan]{'â•'*50}[/]")
        
        files = {
            "subdomains": ("subdomains.txt", "ðŸ”"),
            "live": ("live_hosts.txt", "ðŸŒ"),
            "ports": ("ports.txt", "ðŸ”Œ"),
            "urls": ("urls.txt", "ðŸ”—"),
            "js": ("js_files.txt", "ðŸ“œ"),
        }
        
        for key, (filename, emoji) in files.items():
            if what not in ["all", key]:
                continue
            filepath = target_dir / filename
            if filepath.exists():
                items = load_list(filepath)
                console.print(f"\n[bold]{emoji} {key.upper()}[/] ({len(items)})")
                for item in items[:limit]:
                    console.print(f"  [dim]{item}[/]")
                if len(items) > limit:
                    console.print(f"  [dim]... and {len(items) - limit} more[/]")
        
        # Vulnerabilities
        if what in ["all", "vulns"]:
            vuln_file = target_dir / "nuclei.json"
            if vuln_file.exists():
                vulns = []
                with open(vuln_file) as f:
                    for line in f:
                        if line.strip():
                            try:
                                vulns.append(json.loads(line))
                            except:
                                pass
                if vulns:
                    console.print(f"\n[bold red]ðŸŽ¯ VULNERABILITIES[/] ({len(vulns)})")
                    sev_colors = {"critical": "bold red", "high": "red", "medium": "yellow", "low": "green"}
                    for v in vulns[:limit]:
                        sev = v.get("info", {}).get("severity", "info")
                        name = v.get("info", {}).get("name", v.get("template-id", ""))
                        color = sev_colors.get(sev, "dim")
                        console.print(f"  [{color}][{sev.upper():8}][/] {name}")
    
    return 0

def cmd_tools(args):
    """List tools"""
    if not console:
        return 1
    
    categories = {
        "Subdomain": ["subfinder", "amass", "assetfinder", "findomain"],
        "DNS": ["dnsx", "massdns"],
        "Ports": ["naabu", "masscan", "nmap"],
        "HTTP": ["httpx", "httprobe"],
        "URLs": ["gau", "waybackurls", "katana", "hakrawler"],
        "JS": ["getJS"],
        "Content": ["ffuf", "feroxbuster"],
        "Vulns": ["nuclei"],
        "Screenshots": ["gowitness", "eyewitness"],
        "Utils": ["proxychains4", "jq", "curl"]
    }
    
    table = Table(title="Installed Tools", box=box.ROUNDED, border_style="cyan")
    table.add_column("Category", style="cyan")
    table.add_column("Tool")
    table.add_column("Status", justify="center")
    
    total, installed = 0, 0
    for cat, tools in categories.items():
        for tool in tools:
            total += 1
            if is_installed(tool):
                installed += 1
                table.add_row(cat, tool, "[green]âœ“[/]")
            else:
                table.add_row(cat, tool, "[red]âœ—[/]")
    
    console.print(table)
    pct = int((installed / total) * 100) if total else 0
    color = "green" if pct >= 70 else ("yellow" if pct >= 40 else "red")
    console.print(f"\n[{color}]{installed}/{total} ({pct}%) installed[/]")
    
    if installed < 10:
        console.print("\n[yellow]Tip:[/] Run 'sudo macaron -I' to install tools")
    
    return 0

def cmd_config(args):
    """Config management"""
    config = load_config()
    
    if args.webhook:
        config["discord"]["webhook_url"] = args.webhook
        config["discord"]["enabled"] = True
        save_config(config)
        if console:
            console.print("[green]âœ“ Discord webhook configured[/]")
        if args.test:
            DiscordNotifier().scan_start(["test.com"], "test")
            console.print("[green]âœ“ Test notification sent[/]") if console else None
    elif args.show:
        if console:
            console.print_json(json.dumps(config, indent=2))
        else:
            print(json.dumps(config, indent=2))
    
    return 0

def cmd_export(args):
    """Export results"""
    output = Path(args.output) if args.output else Path(f"macaron_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json")
    
    data = {"exported_at": get_timestamp(), "targets": {}}
    
    if DATA_DIR.exists():
        for d in DATA_DIR.iterdir():
            if d.is_dir():
                if args.domain and args.domain not in d.name:
                    continue
                target_data = {"name": d.name}
                for f in ["subdomains.txt", "live_hosts.txt", "urls.txt", "ports.txt"]:
                    fp = d / f
                    if fp.exists():
                        target_data[f.replace(".txt", "")] = load_list(fp)
                data["targets"][d.name] = target_data
    
    with open(output, 'w') as f:
        json.dump(data, f, indent=2)
    
    console.print(f"[green]âœ“ Exported to {output}[/]") if console else print(f"Exported to {output}")
    return 0

def cmd_install(args):
    """Install tools"""
    if os.geteuid() != 0:
        console.print("[red]âœ— Please run with sudo[/]") if console else print("Run with sudo")
        return 1
    
    console.print("[cyan]Installing reconnaissance tools...[/]") if console else print("Installing...")
    
    # Install Go tools
    go_tools = [
        "github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest",
        "github.com/projectdiscovery/httpx/cmd/httpx@latest",
        "github.com/projectdiscovery/dnsx/cmd/dnsx@latest",
        "github.com/projectdiscovery/naabu/v2/cmd/naabu@latest",
        "github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest",
        "github.com/projectdiscovery/katana/cmd/katana@latest",
        "github.com/tomnomnom/assetfinder@latest",
        "github.com/tomnomnom/waybackurls@latest",
        "github.com/sensepost/gowitness@latest",
        "github.com/ffuf/ffuf/v2@latest",
        "github.com/hakluke/hakrawler@latest",
        "github.com/lc/gau/v2/cmd/gau@latest",
        "github.com/003random/getJS@latest",
    ]
    
    os.environ["GOPATH"] = str(Path.home() / "go")
    os.environ["PATH"] = os.environ["PATH"] + ":" + str(Path.home() / "go" / "bin")
    
    for tool in go_tools:
        name = tool.split('/')[-1].split('@')[0]
        console.print(f"  Installing {name}...") if console else print(f"Installing {name}")
        subprocess.run(["go", "install", tool], capture_output=True)
    
    # Copy to /usr/local/bin
    go_bin = Path.home() / "go" / "bin"
    if go_bin.exists():
        for f in go_bin.iterdir():
            shutil.copy(str(f), "/usr/local/bin/")
    
    console.print("[green]âœ“ Installation complete![/]") if console else print("Done!")
    return 0

# ============== MAIN ==============

def main():
    parser = argparse.ArgumentParser(
        prog="macaron",
        description="Macaron v2 - Security Reconnaissance Platform",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  macaron -s example.com              Wide scan
  macaron -s app.com -n               Narrow scan  
  macaron -s target.com -f            Fast scan
  macaron -s target.com --slow        Slow mode (ISP friendly)
  macaron -S                          Show status
  macaron -L                          List tools
  macaron -R -d example.com           Show results
        """
    )
    
    # Main actions (short flags)
    parser.add_argument("-s", "--scan", dest="target", nargs="*", metavar="TARGET", help="Scan target(s)")
    parser.add_argument("-S", "--status", action="store_true", help="Show status & summary")
    parser.add_argument("-R", "--results", action="store_true", help="Show results")
    parser.add_argument("-L", "--list-tools", action="store_true", help="List installed tools")
    parser.add_argument("-E", "--export", action="store_true", help="Export results")
    parser.add_argument("-I", "--install", action="store_true", help="Install recon tools (sudo)")
    parser.add_argument("-C", "--config", action="store_true", help="Show config")
    
    # Scan options
    parser.add_argument("-f", "--fast", action="store_true", help="Fast mode (minimal tools)")
    parser.add_argument("-n", "--narrow", action="store_true", help="Narrow mode (app-focused)")
    parser.add_argument("-F", "--file", metavar="FILE", help="Targets from file")
    parser.add_argument("--stdin", action="store_true", help="Read from stdin")
    parser.add_argument("--no-proxy", action="store_true", help="Disable proxychains")
    parser.add_argument("--slow", action="store_true", help="Slow mode (10 req/s)")
    parser.add_argument("--rate", type=int, help="Rate limit (req/s)")
    parser.add_argument("--threads", type=int, help="Threads")
    parser.add_argument("-q", "--quiet", action="store_true", help="Quiet mode")
    
    # Results options
    parser.add_argument("-d", "--domain", help="Filter by domain")
    parser.add_argument("-w", "--what", choices=["all", "subdomains", "live", "ports", "urls", "js", "vulns"], help="What to show")
    parser.add_argument("--limit", type=int, default=50, help="Limit results")
    
    # Config options
    parser.add_argument("--webhook", metavar="URL", help="Set Discord webhook")
    parser.add_argument("--test", action="store_true", help="Test webhook")
    parser.add_argument("--show", action="store_true", help="Show config")
    
    # Export options
    parser.add_argument("-o", "--output", help="Output file")
    
    # Meta
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose")
    parser.add_argument("--version", action="version", version=f"macaron {VERSION}")
    
    args = parser.parse_args()
    
    # Route to appropriate command
    if args.target is not None:
        return cmd_scan(args)
    elif args.status:
        return cmd_status(args)
    elif args.results:
        return cmd_show(args)
    elif args.list_tools:
        return cmd_tools(args)
    elif args.export:
        return cmd_export(args)
    elif args.install:
        return cmd_install(args)
    elif args.config or args.webhook:
        return cmd_config(args)
    else:
        # Show help with banner
        if console:
            console.print(Panel(BANNER.format(version=VERSION), border_style="cyan", box=box.DOUBLE))
        parser.print_help()
        return 0

if __name__ == "__main__":
    sys.exit(main())
